}
# Try out different numbers of clustering and see which one has the highest silhouette score (meaning it best divides the data)
# Due to computational constraints we select just a subset of the original observations, 1/7, to tune this hyperparameter
for (n_clusters in 2:10) {
# Perform k-means clustering
kmeans_result <- kmeans(sample_cardio_data_scaled, centers = n_clusters)
# Extract cluster labels from the k-means result
cluster_labels <- kmeans_result$cluster
# Calculate silhouette values
sil <- silhouette(cluster_labels, dist_matrix)
# Store the average silhouette score for the current number of clusters
silhouette_scores[n_clusters] <- mean(sil[, 3])
}
max_silhouette_kmeans = which.max(silhouette_scores)
best_kmeans_result <- kmeans(cardio_data_scaled, centers = max_silhouette_kmeans)
# Add the cluster assignment to the original data
cardio$Cluster <- as.factor(best_kmeans_result$cluster)
str(best_kmeans_result)
# Visualize the clusters across different dimensions
cl_p1 = ggplot(cardio, aes(cardio, ap_hi, color = Cluster)) +
geom_point() +
labs(title = "K-Means Clustering (cardio vs ap_hi)")
cl_p2 = ggplot(cardio, aes(cardio, ap_lo, color = Cluster)) +
geom_point() +
labs(title = "K-Means Clustering (cardio vs ap_lo)")
grid.arrange(cl_p1, cl_p2)
suppressMessages(library(gridExtra))
grid.arrange(cl_p1, cl_p2)
# setup for better visualization
cardio$gender <- factor(cardio$gender)
levels(cardio$gender) = c("F", "M")
cardio$cardio <- as.factor(cardio$cardio)
cardio$cholesterol <- factor(cardio$cholesterol)
levels(cardio$cholesterol) = c("normal", "above normal", "well above normal")
cardio$gluc <- factor(cardio$gluc)
levels(cardio$gluc) = c("normal", "above normal", "well above normal")
cardio$smoke <- factor(cardio$smoke)
levels(cardio$smoke) = c("No", "Yes")
cardio$alco <- factor(cardio$alco)
levels(cardio$alco) = c("No", "Yes")
cardio$active <- factor(cardio$active)
levels(cardio$active) = c("No", "Yes")
# Add the cluster assignment to the original data
cardio$Cluster <- as.factor(best_kmeans_result$cluster)
str(best_kmeans_result)
# Visualize the clusters across different dimensions
cl_p1 = ggplot(cardio, aes(cardio, ap_hi, color = Cluster)) +
geom_point() +
labs(title = "K-Means Clustering (cardio vs ap_hi)")
cl_p2 = ggplot(cardio, aes(cardio, ap_lo, color = Cluster)) +
geom_point() +
labs(title = "K-Means Clustering (cardio vs ap_lo)")
grid.arrange(cl_p1, cl_p2)
cl_p3 = ggplot(cardio, aes(ap_hi, ap_lo, color = Cluster)) +
geom_point() +
labs(title = "K-Means Clustering (ap_hi vs ap_lo)")
cardio_pl = ggplot(cardio, aes(ap_hi, ap_lo, color = cardio)) +
geom_point() +
labs(title = "K-Means Clustering (ap_hi vs ap_lo)")
grid.arrange(cl_p3, cardio_pl)
cardio_with_id <- read.csv("data/cardio_train.csv", sep= ";", header=TRUE)
cardio <- cardio_with_id[,-1]
sum(as.numeric(is.na(cardio)))
str(cardio)
summary(cardio)
par(mfrow = c(2,2))
summary(cardio[(cardio$ap_hi<0|cardio$ap_hi>400|cardio$ap_lo<0|cardio$ap_lo>400|cardio$ap_hi<cardio$ap_lo),])
cardio <- cardio[!(cardio$ap_hi < 0 | cardio$ap_hi > 400 | cardio$ap_lo < 0 | cardio$ap_lo > 400 | cardio$ap_hi < cardio$ap_lo | cardio$ap_hi-cardio$ap_lo > 250),]
cardio_cl <- cardio
# setup for better visualization
cardio$gender <- factor(cardio$gender)
levels(cardio$gender) = c("F", "M")
cardio$cardio <- as.factor(cardio$cardio)
cardio$cholesterol <- factor(cardio$cholesterol)
levels(cardio$cholesterol) = c("normal", "above normal", "well above normal")
cardio$gluc <- factor(cardio$gluc)
levels(cardio$gluc) = c("normal", "above normal", "well above normal")
cardio$smoke <- factor(cardio$smoke)
levels(cardio$smoke) = c("No", "Yes")
cardio$alco <- factor(cardio$alco)
levels(cardio$alco) = c("No", "Yes")
cardio$active <- factor(cardio$active)
levels(cardio$active) = c("No", "Yes")
# Scale the data to normalize the values
cardio_data_scaled <- scale(cardio_cl[, -12])
# View the first few rows of the dataset
head(cardio_data_scaled)
# Compute the distance matrix for the scaled data
sample_cardio_data_scaled = sample(cardio_data_scaled, 10000)
dist_matrix <- dist(sample_cardio_data_scaled)
# Perform K-means clustering
set.seed(123)
silhouette_scores = c()
# Try out different numbers of clustering and see which one has the highest silhouette score (meaning it best divides the data)
# Due to computational constraints we select just a subset of the original observations, 1/7, to tune this hyperparameter
for (n_clusters in 2:10) {
# Perform k-means clustering
kmeans_result <- kmeans(sample_cardio_data_scaled, centers = n_clusters)
# Extract cluster labels from the k-means result
cluster_labels <- kmeans_result$cluster
# Calculate silhouette values
sil <- silhouette(cluster_labels, dist_matrix)
# Store the average silhouette score for the current number of clusters
silhouette_scores[n_clusters] <- mean(sil[, 3])
}
# Try out different numbers of clustering and see which one has the highest silhouette score (meaning it best divides the data)
# Due to computational constraints we select just a subset of the original observations, 1/7, to tune this hyperparameter
for (n_clusters in 2:10) {
# Perform k-means clustering
kmeans_result <- kmeans(sample_cardio_data_scaled, centers = n_clusters)
# Extract cluster labels from the k-means result
cluster_labels <- kmeans_result$cluster
# Calculate silhouette values
sil <- silhouette(cluster_labels, dist_matrix)
# Store the average silhouette score for the current number of clusters
silhouette_scores[n_clusters] <- mean(sil[, 3])
}
max_silhouette_kmeans = which.max(silhouette_scores)
best_kmeans_result <- kmeans(cardio_data_scaled, centers = max_silhouette_kmeans)
# Add the cluster assignment to the original data
cardio$Cluster <- as.factor(best_kmeans_result$cluster)
str(best_kmeans_result)
table(cardio$Cluster)
# Visualize the clusters across different dimensions
cl_p1 = ggplot(cardio, aes(cardio, ap_hi, color = Cluster)) +
geom_point() +
labs(title = "K-Means Clustering (cardio vs ap_hi)")
cl_p2 = ggplot(cardio, aes(cardio, ap_lo, color = Cluster)) +
geom_point() +
labs(title = "K-Means Clustering (cardio vs ap_lo)")
grid.arrange(cl_p1, cl_p2)
cl_p3 = ggplot(cardio, aes(ap_hi, ap_lo, color = Cluster)) +
geom_point() +
labs(title = "K-Means Clustering (ap_hi vs ap_lo)")
cardio_pl = ggplot(cardio, aes(ap_hi, ap_lo, color = cardio)) +
geom_point() +
labs(title = "K-Means Clustering (ap_hi vs ap_lo)")
grid.arrange(cl_p3, cardio_pl)
info_cluster1 = cardio %>% filter(Cluster == 1)
summary(info_cluster1)
info_cluster2 = cardio %>% filter(Cluster == 2)
summary(info_cluster2)
cluster_differences = c()
for (i in continuous_vars){
wilcox_test_result <- wilcox.test(ap_hi ~ Cluster, data = cardio)
cluster_differences[i] = wilcox_test_result$p.value
print(wilcox_test_result$p.value)
}
categorical_vars <- names(cardio)[!names(cardio) %in% c("cardio", continuous_vars)]
cluster_differences = c()
continuous_vars = c("ap_hi", "ap_lo", "weight", "height", "age")
categorical_vars <- names(cardio)[!names(cardio) %in% c("cardio", continuous_vars)]
for (i in continuous_vars){
wilcox_test_result <- wilcox.test(ap_hi ~ Cluster, data = cardio)
cluster_differences[i] = wilcox_test_result$p.value
print(wilcox_test_result$p.value)
}
for (i in categorical_vars){
# Create a contingency table
contingency_table <- table(cardio[[i]], cardio$Cluster)
# Perform the Chi-Square test
chi_square_result <- chisq.test(contingency_table)
cluster_differences[i] = chi_square_result$p.value
print(chi_square_result$p.value)
}
cluster_differences
# Filter the dataset to exclude these columns and scale the remaining numeric columns
cardio_cl[, c(continuous_vars, "cardio")] <- scale(cardio_cl[, c(continuous_vars, "cardio")])
cardio_data_scaled <- cardio_cl
# View the first few rows of the dataset
head(cardio_data_scaled)
# Compute the distance matrix for the scaled data
sample_cardio_data_scaled = sample(as.matrix(cardio_data_scaled), 10000)
dist_matrix <- dist(sample_cardio_data_scaled)
head(dist_matrix)
# Perform K-means clustering
set.seed(123)
silhouette_scores = c()
# Try out different numbers of clustering and see which one has the highest silhouette score (meaning it best divides the data)
# Due to computational constraints we select just a subset of the original observations, 1/7, to tune this hyperparameter
for (n_clusters in 2:10) {
# Perform k-means clustering
kmeans_result <- kmeans(sample_cardio_data_scaled, centers = n_clusters)
# Extract cluster labels from the k-means result
cluster_labels <- kmeans_result$cluster
# Calculate silhouette values
sil <- silhouette(cluster_labels, dist_matrix)
# Store the average silhouette score for the current number of clusters
silhouette_scores[n_clusters] <- mean(sil[, 3])
}
# Try out different numbers of clustering and see which one has the highest silhouette score (meaning it best divides the data)
# Due to computational constraints we select just a subset of the original observations, 1/7, to tune this hyperparameter
for (n_clusters in 2:10) {
# Perform k-means clustering
kmeans_result <- kmeans(sample_cardio_data_scaled, centers = n_clusters)
# Extract cluster labels from the k-means result
cluster_labels <- kmeans_result$cluster
# Calculate silhouette values
sil <- silhouette(cluster_labels, dist_matrix)
# Store the average silhouette score for the current number of clusters
silhouette_scores[n_clusters] <- mean(sil[, 3])
}
max_silhouette_kmeans = which.max(silhouette_scores)
best_kmeans_result <- kmeans(cardio_data_scaled, centers = max_silhouette_kmeans)
# Add the cluster assignment to the original data
cardio$Cluster <- as.factor(best_kmeans_result$cluster)
table(cardio$Cluster)
# Visualize the clusters across different dimensions
cl_p1 = ggplot(cardio, aes(cardio, ap_hi, color = Cluster)) +
geom_point() +
labs(title = "K-Means Clustering (cardio vs ap_hi)")
cl_p2 = ggplot(cardio, aes(cardio, ap_lo, color = Cluster)) +
geom_point() +
labs(title = "K-Means Clustering (cardio vs ap_lo)")
grid.arrange(cl_p1, cl_p2)
cl_p3 = ggplot(cardio, aes(ap_hi, ap_lo, color = Cluster)) +
geom_point() +
labs(title = "K-Means Clustering (ap_hi vs ap_lo)")
cardio_pl = ggplot(cardio, aes(ap_hi, ap_lo, color = cardio)) +
geom_point() +
labs(title = "K-Means Clustering (ap_hi vs ap_lo)")
grid.arrange(cl_p3, cardio_pl)
cluster_differences = c()
for (i in continuous_vars){
wilcox_test_result <- wilcox.test(ap_hi ~ Cluster, data = cardio)
cluster_differences[i] = wilcox_test_result$p.value
print(wilcox_test_result$p.value)
}
?wilcox.test
# !!! justify wilcox text
for (i in continuous_vars){
wilcox_test_result <- wilcox.test(i ~ Cluster, data = cardio)
cluster_differences[i] = wilcox_test_result$p.value
print(wilcox_test_result$p.value)
}
cluster_differences = c()
for (i in continuous_vars){
anova <- aov(cardio[, "ap_hi"] ~ cardio[, "Cluster"])
cluster_differences[i] = summary(anova_test)[[1]][["Pr(>F)"]][1]
print(wilcox_test_result$p.value)
}
cluster_differences = c()
for (i in continuous_vars){
anova <- aov(cardio[, "ap_hi"] ~ cardio[, "Cluster"])
cluster_differences[i] = summary(anova)[[1]][["Pr(>F)"]][1]
print(wilcox_test_result$p.value)
}
for (i in continuous_vars){
anova <- aov(cardio[, i] ~ cardio[, "Cluster"])
cluster_differences[i] = summary(anova)[[1]][["Pr(>F)"]][1]
print(wilcox_test_result$p.value)
}
for (i in categorical_vars){
# Create a contingency table
contingency_table <- table(cardio[[i]], cardio$Cluster)
# Perform the Chi-Square test
chi_square_result <- chisq.test(contingency_table)
cluster_differences[i] = chi_square_result$p.value
print(chi_square_result$p.value)
}
cluster_differences
cardio_data_scaled <- scale(cardio_cl[, continuous_vars])
# View the first few rows of the dataset
head(cardio_data_scaled)
# Compute the distance matrix for the scaled data
sample_cardio_data_scaled = sample(cardio_data_scaled, 10000)
dist_matrix <- dist(sample_cardio_data_scaled)
# Compute the distance matrix for the scaled data
sample_cardio_data_scaled = sample(cardio_data_scaled, 10000)
dist_matrix <- dist(sample_cardio_data_scaled)
head(dist_matrix)
# Perform K-means clustering
set.seed(123)
silhouette_scores = c()
# Try out different numbers of clustering and see which one has the highest silhouette score (meaning it best divides the data)
# Due to computational constraints we select just a subset of the original observations, 1/7, to tune this hyperparameter
for (n_clusters in 2:10) {
# Perform k-means clustering
kmeans_result <- kmeans(sample_cardio_data_scaled, centers = n_clusters)
# Extract cluster labels from the k-means result
cluster_labels <- kmeans_result$cluster
# Calculate silhouette values
sil <- silhouette(cluster_labels, dist_matrix)
# Store the average silhouette score for the current number of clusters
silhouette_scores[n_clusters] <- mean(sil[, 3])
}
# Try out different numbers of clustering and see which one has the highest silhouette score (meaning it best divides the data)
# Due to computational constraints we select just a subset of the original observations, 1/7, to tune this hyperparameter
for (n_clusters in 2:10) {
# Perform k-means clustering
kmeans_result <- kmeans(sample_cardio_data_scaled, centers = n_clusters)
# Extract cluster labels from the k-means result
cluster_labels <- kmeans_result$cluster
# Calculate silhouette values
sil <- silhouette(cluster_labels, dist_matrix)
# Store the average silhouette score for the current number of clusters
silhouette_scores[n_clusters] <- mean(sil[, 3])
}
max_silhouette_kmeans = which.max(silhouette_scores)
best_kmeans_result <- kmeans(cardio_data_scaled, centers = max_silhouette_kmeans)
# Add the cluster assignment to the original data
cardio$Cluster <- as.factor(best_kmeans_result$cluster)
table(cardio$Cluster)
# Visualize the clusters across different dimensions
cl_p1 = ggplot(cardio, aes(cardio, ap_hi, color = Cluster)) +
geom_point() +
labs(title = "K-Means Clustering (cardio vs ap_hi)")
cl_p2 = ggplot(cardio, aes(cardio, ap_lo, color = Cluster)) +
geom_point() +
labs(title = "K-Means Clustering (cardio vs ap_lo)")
grid.arrange(cl_p1, cl_p2)
cl_p3 = ggplot(cardio, aes(ap_hi, ap_lo, color = Cluster)) +
geom_point() +
labs(title = "K-Means Clustering (ap_hi vs ap_lo)")
cardio_pl = ggplot(cardio, aes(ap_hi, ap_lo, color = cardio)) +
geom_point() +
labs(title = "K-Means Clustering (ap_hi vs ap_lo)")
grid.arrange(cl_p3, cardio_pl)
cluster_differences = c()
for (i in continuous_vars){
anova <- aov(cardio[, i] ~ cardio[, "Cluster"])
cluster_differences[i] = summary(anova)[[1]][["Pr(>F)"]][1]
print(wilcox_test_result$p.value)
}
for (i in categorical_vars){
# Create a contingency table
contingency_table <- table(cardio[[i]], cardio$Cluster)
# Perform the Chi-Square test
chi_square_result <- chisq.test(contingency_table)
cluster_differences[i] = chi_square_result$p.value
print(chi_square_result$p.value)
}
cluster_differences
library(klaR)
# Scale the data to normalize the values
# Create a vector of column names to exclude
columns_to_exclude <- c(continuous_vars, "cardio")
# Filter the dataset to exclude these columns and scale the remaining numeric columns
cardio_data_modes <- cardio_cl[, !colnames(cardio_cl) %in% columns_to_exclude]
# View the first few rows of the dataset
head(cardio_data_modes)
# Perform K-modes clustering
set.seed(123)
modes_cost = c()
# Compute the distance matrix for the scaled data
sample_cardio_data_modes = cardio_data_modes[1:1000, ]
#dist_matrix_modes <- dist(sample_cardio_data_modes, method = "binary")
dist_matrix_modes = daisy(sample_cardio_data_modes, metric = "gower")
# Due to computational constraints we select just a subset of the original observations, 1/7, to tune this hyperparameter
for (n_modes in 2:10) {
# Perform k-means clustering
kmodes_result <- kmodes(sample_cardio_data_modes, modes = n_modes)
# Extract cluster labels from the k-means result
modes_labels <- kmodes_result$modes
# Store the average silhouette score for the current number of clusters
modes_cost[n_modes] <-sum(kmodes_result$withindiff)
}
min_cost_kmodes = which.min(modes_cost)
best_kmodes_result <- kmodes(cardio_data_modes, modes = max_silhouette_kmodes)
best_kmodes_result <- kmodes(cardio_data_modes, modes = min_cost_kmodes)
best_kmodes_result <- kmodes(cardio_data_modes, modes = min_cost_kmodes)
min_cost_kmodes
# Add the cluster assignment to the original data
cardio$Cluster_modes <- as.factor(best_kmodes_result$cluster)
str(best_kmodes_result)
table(cardio$Cluster_modes)
# Visualize the clusters across different dimensions
modes_p1 = ggplot(cardio, aes(cardio, ap_hi, color = Cluster_modes)) +
geom_point() +
labs(title = "K-Means Clustering (cardio vs ap_hi)")
modes_p2 = ggplot(cardio, aes(cardio, ap_lo, color = Cluster_modes)) +
geom_point() +
labs(title = "K-Means Clustering (cardio vs ap_lo)")
grid.arrange(modes_p1, modes_p2)
modes_p3 = ggplot(cardio, aes(ap_hi, ap_lo, color = Cluster)) +
geom_point() +
labs(title = "K-Means Clustering (ap_hi vs ap_lo)")
cardio_pl = ggplot(cardio, aes(ap_hi, ap_lo, color = cardio)) +
geom_point() +
labs(title = "K-Means Clustering (ap_hi vs ap_lo)")
grid.arrange(modes_p3, cardio_pl)
modes_p3 = ggplot(cardio, aes(ap_hi, ap_lo, color = Cluster)) +
geom_point() +
labs(title = "K-Modes Clustering (ap_hi vs ap_lo)")
cardio_pl = ggplot(cardio, aes(ap_hi, ap_lo, color = cardio)) +
geom_point() +
labs(title = "K-Modes Clustering (ap_hi vs ap_lo)")
grid.arrange(modes_p3, cardio_pl)
# Perform K-means clustering
set.seed(123)
silhouette_scores = c()
# Try out different numbers of clustering and see which one has the highest silhouette score (meaning it best divides the data)
# Due to computational constraints we select just a subset of the original observations, 1/7, to tune this hyperparameter
for (n_clusters in 2:10) {
# Perform k-means clustering
kmeans_result <- kmeans(sample_cardio_data_scaled, centers = n_clusters)
# Extract cluster labels from the k-means result
cluster_labels <- kmeans_result$cluster
# Calculate silhouette values
sil <- silhouette(cluster_labels, dist_matrix)
# Store the average silhouette score for the current number of clusters
silhouette_scores[n_clusters] <- mean(sil[, 3])
}
# Try out different numbers of clustering and see which one has the highest silhouette score (meaning it best divides the data)
# Due to computational constraints we select just a subset of the original observations, 1/7, to tune this hyperparameter
for (n_clusters in 2:10) {
# Perform k-means clustering
kmeans_result <- kmeans(sample_cardio_data_scaled, centers = n_clusters)
# Extract cluster labels from the k-means result
cluster_labels <- kmeans_result$cluster
# Calculate silhouette values
sil <- silhouette(cluster_labels, dist_matrix)
# Store the average silhouette score for the current number of clusters
silhouette_scores[n_clusters] <- mean(sil[, 3])
}
max_silhouette_kmeans = which.max(silhouette_scores)
modes_cluster_differences = c()
modes_cluster_differences = c()
for (i in continuous_vars){
anova <- aov(cardio[, i] ~ cardio[, "Cluster"])
modes_cluster_differences[i] = summary(anova)[[1]][["Pr(>F)"]][1]
print(wilcox_test_result$p.value)
}
modes_cluster_differences = c()
modes_cluster_differences = c()
for (i in continuous_vars){
anova <- aov(cardio[, i] ~ cardio[, "Cluster"])
modes_cluster_differences[i] = summary(anova)[[1]][["Pr(>F)"]][1]
}
for (i in categorical_vars){
# Create a contingency table
contingency_table <- table(cardio[[i]], cardio$Cluster)
# Perform the Chi-Square test
chi_square_result <- chisq.test(contingency_table)
modes_cluster_differences[i] = chi_square_result$p.value
print(chi_square_result$p.value)
}
modes_cluster_differences
# Scale the data to normalize the values
cardio_data_scaled1 <- scale(cardio_cl[, -12])
# View the first few rows of the dataset
head(cardio_data_scaled1)
# Compute the distance matrix for the scaled data
sample_cardio_data_scaled1 = sample(cardio_data_scaled, 10000)
dist_matrix1 <- dist(sample_cardio_data_scaled)
# Perform K-means clustering
set.seed(123)
silhouette_scores1 = c()
# Scale the data to normalize the values
cardio_data_scaled1 <- scale(cardio_cl[, -12])
# View the first few rows of the dataset
head(cardio_data_scaled1)
# Compute the distance matrix for the scaled data
sample_cardio_data_scaled1 = sample(cardio_data_scaled, 10000)
dist_matrix1 <- dist(sample_cardio_data_scaled)
head(dist_matrix1)
# Perform K-means clustering
set.seed(123)
silhouette_scores1 = c()
# Try out different numbers of clustering and see which one has the highest silhouette score (meaning it best divides the data)
# Due to computational constraints we select just a subset of the original observations, 1/7, to tune this hyperparameter
for (n_clusters in 2:10) {
# Perform k-means clustering
kmeans_result1 <- kmeans(sample_cardio_data_scaled, centers = n_clusters)
# Extract cluster labels from the k-means result
cluster_labels1 <- kmeans_result1$cluster
# Calculate silhouette values
sil1 <- silhouette(cluster_labels1, dist_matrix1)
# Store the average silhouette score for the current number of clusters
silhouette_scores1[n_clusters] <- mean(sil1[, 3])
}
# Try out different numbers of clustering and see which one has the highest silhouette score (meaning it best divides the data)
# Due to computational constraints we select just a subset of the original observations, 1/7, to tune this hyperparameter
for (n_clusters in 2:10) {
# Perform k-means clustering
kmeans_result1 <- kmeans(sample_cardio_data_scaled, centers = n_clusters)
# Extract cluster labels from the k-means result
cluster_labels1 <- kmeans_result1$cluster
# Calculate silhouette values
sil1 <- silhouette(cluster_labels1, dist_matrix1)
# Store the average silhouette score for the current number of clusters
silhouette_scores1[n_clusters] <- mean(sil1[, 3])
}
max_silhouette_kmeans1 = which.max(silhouette_scores)
best_kmeans_result1 <- kmeans(cardio_data_scaled, centers = max_silhouette_kmeans)
# Add the cluster assignment to the original data
cardio$Cluster1 <- as.factor(best_kmeans_result$cluster)
# Add the cluster assignment to the original data
cardio$Cluster1 <- as.factor(best_kmeans_result$cluster)
table(cardio$Cluster1)
# Visualize the clusters across different dimensions
cl_p1 = ggplot(cardio, aes(cardio, ap_hi, color = Cluster1)) +
geom_point() +
labs(title = "K-Means Clustering (cardio vs ap_hi)")
cl_p2 = ggplot(cardio, aes(cardio, ap_lo, color = Cluster1)) +
geom_point() +
labs(title = "K-Means Clustering (cardio vs ap_lo)")
grid.arrange(cl_p1, cl_p2)
cl_p3 = ggplot(cardio, aes(ap_hi, ap_lo, color = Cluster1)) +
geom_point() +
labs(title = "K-Means Clustering (ap_hi vs ap_lo)")
cardio_pl = ggplot(cardio, aes(ap_hi, ap_lo, color = cardio)) +
geom_point() +
labs(title = "K-Means Clustering (ap_hi vs ap_lo)")
cardio_pl = ggplot(cardio, aes(ap_hi, ap_lo, color = cardio)) +
geom_point() +
labs(title = "K-Means Clustering (ap_hi vs ap_lo)")
grid.arrange(cl_p3, cardio_pl)
cardio_with_id <- read.csv("data/cardio_train.csv", sep= ";", header=TRUE)
cardio_with_id <- read.csv("data/cardio_train.csv", sep= ";", header=TRUE)
summary(cardio)
par(mfrow = c(2,2))
